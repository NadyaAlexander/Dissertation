---
title: "gate_regression"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# 1.0 Data 
## 1.1 Data Gathering
```{r datagathering}
# put all the flow data from the different type of gates here
flowdf <- list()

# check.names=FALSE removes leadinging X's from column names
flowdf[[1]] <- read.csv("inputs/armco_gate36.csv", header = TRUE, check.names = FALSE)
flowdf[[2]] <- read.csv("inputs/armco_gate36.csv", header = TRUE, check.names = FALSE)
flowdf[[3]] <- read.csv("inputs/armco_gate36.csv", header = TRUE, check.names = FALSE)
flowdf[[4]] <- read.csv("inputs/armco_gate36.csv", header = TRUE, check.names = FALSE)
ngates <- length(flowdf)
```

## 1.2 Data Preprocessing
```{r preprocessing}
library(reshape2) 
preprocessing <- function(data){
  # deleting last two NA rows from stubborn Excel
  data <- na.omit(data)
  # reshape the data from wide to long format
  datalong <- melt(data, id.vars = "H", measure.var = 2:ncol(data), var.name = colnames(data), value.name = 'FLOW', variable.name = "G")
  datalong$LOGFLOW <- log(datalong$FLOW)
  datalong$G <- as.numeric(datalong$G)
  datalong
}

# now we can easily apply the function we wrote to all elements of the list with lapply
flowdfl <- lapply(flowdf, preprocessing)

# to take a look do this
head(flowdfl[[ngates]])
tail(flowdfl[[ngates]])
```

# 2.0 Model Simulations
models will come in 8 forms, complex to simple.
data will come in 4 forms, for each gate type. (subject to change)
Therefore, we will have 8*4=32 models. (subject to change)

```{r simulations}
library(nls2)

# note these models were only written for one flow dataframe: flowdf[[1]]
# attempt 1: model form is 
# Q = (aG^2 + bG + c)*H^(dG^2 + eG + f)
# log[Q] = log[(aG^2 + bG + c)*H^(dG + eG + f)]
# log[Q] = log[(aG^2 + bG + c)] +(dG + eG + f)*log[H]
modelsim <- nls(LOGFLOW~log(A*G^2+B*G+C)+(D*G^2+E*G+FF)*log(H), data=flowdfl[[1]], start=list(A=0, B=0.5, C=2, D=0, E=0, FF=0.5))

# attempt 2: model form is 
# Q = (bG + c)*H^(dG^2 + eG + f)
# log[Q] = log[(bG + c)*H^(dG + eG + f)]
# log[Q] = log[(bG + c)] +(dG + eG + f)*log[H]
modelsim <- nls(LOGFLOW~log(B*G+C)+(D*G^2+E*G+FF)*log(H), data=flowdfl[[1]], start=list(B=1, C=1, D=1, E=1, FF=1))

# attempt 3: model form is
# Q = (aG^2 + bG + c)*H^(eG + f)
# log[Q] = log[(aG^2 + bG + c)*H^(eG + f)]
# log[Q] = log[(aG^2 + bG + c)] + (eG + f)*log[H]
modelsim <- nls(LOGFLOW~log(A*G^2+B*G+C)+(E*G+FF)*log(H), data=flowdfl[[1]], start=list(A=0, B=0.5, C=2.5, E=0, FF=0.5))

# attempt 4: model form is
# Q = (c)*H^(dG^2 + eG + f)
# log[Q] = log[(c)*H^(dG^2 + eG + f)]
# log[Q] = log[(c)] +(dG^2 + eG + f)*log[H]
modelsim <- nls(LOGFLOW~log(C)+(D*G^2+E*G+FF)*log(H), data=flowdfl[[1]], start=list(C=1, D=1, E=1, FF=1))

# attempt 5: model form is
# Q = (aG^2 + bG + c)*H^(f)
# log[Q] = log[(aG^2 + bG + c)*H^(f)]
# log[Q] = log[(aG^2 + bG + c)] +(f)*log[H]
modelsim <- nls(LOGFLOW~log(A*G^2+B*G+C)+(FF)*log(H), data=flowdfl[[1]], start=list(A=0, B=0.5, C=2.5, FF=0.5))

# attempt 6: model form is
# Q = (c)*H^(eG + f)
# log[Q] = log[(c)*H^(eG + f)]
# log[Q] = log[(c)] +(eG + f)*log[H]
modelsim <- nls(LOGFLOW~log(C)+(E*G+FF)*log(H), data=flowdfl[[1]], start=list(C=1, E=1, FF=1))

# attempt 7: model form is
# Q = (bG + c)*H^(f)
# log[Q] = log[(bG + c)*H^(f)]
# log[Q] = log[(bG + c)] +(f)*log[H]
modelsim <- nls(LOGFLOW~log(B*G+C)+(FF)*log(H), data=flowdfl[[1]], start=list(B=1, C=1, FF=1))

# attempt 8: model form is
# Q = (G)*H^(f)
# log[Q] = log[(G)*H^(f)]
# log[Q] = log[(G)] + (f)*log[H]
modelsim <- nls(LOGFLOW~log(G)+(FF)*log(H), data=flowdfl[[1]], start=list(FF=1))

# run this to see the optimized parameters in the description
modelsim
```

```{r siminputs}
# check these with Nadya

# model formulas
formulastring <- list()
formulastring[[1]] <- "LOGFLOW ~log(A*G^2+B*G+C)+(D*G^2+E*G+FF)*log(H)"
formulastring[[2]] <- "LOGFLOW ~log(B*G+C)+(D*G^2+E*G+FF)*log(H)"
formulastring[[3]] <- "LOGFLOW ~log(A*G^2+B*G+C)+(E*G+FF)*log(H)"
formulastring[[4]] <- "LOGFLOW ~log(C)+(D*G^2+E*G+FF)*log(H)"
formulastring[[5]] <- "LOGFLOW ~log(A*G^2+B*G+C)+(FF)*log(H)"
formulastring[[6]] <- "LOGFLOW ~log(C)+(E*G+FF)*log(H)"
formulastring[[7]] <- "LOGFLOW ~log(B*G+C)+(FF)*log(H)"
formulastring[[8]] <- "LOGFLOW ~log(G)+(FF)*log(H)"
nformulas <- length(formulastring)
  
# term starts:    attempt No.1    2   3    4   5    6   7   8          
termstart <- data.frame( A=c(0,   NA, 0,   NA, 0,   NA, NA, NA), 
                         B=c(0.5, 1,  0.5, NA, 0.5, NA, 1,  NA), 
                         C=c(2,   1,  2.5, 1,  2.5, 1,  1,  NA), 
                         D=c(0,   1,  NA,  1,  NA,  NA, NA, NA), 
                         E=c(0,   1,  0,   1,  NA,  1,  NA, NA), 
                        FF=c(0.5, 1,  0.5, 1,  0.5, 1,  1,  1))
```

```{r simfunction}
modelsim <- function(data, formulastring, termstart){
  nls(as.formula(formulastring), data=data, start=termstart)
}

# d for the number of flow dataframes
# m for the number of model forms
modelfits <- replicate(n=4, expr=list())
for(d in 1:ngates){
  for (m in 1:nformulas){
    termstartsub <- list(A=termstart[m, 1], B=termstart[m, 2], C=termstart[m, 3], D=termstart[m, 4], E=termstart[m, 5], FF=termstart[m, 6])
    termstartsub <- termstartsub[!is.na(termstartsub)]
    modelfits[[d]][[m]] <- modelsim(flowdfl[[d]], formulastring[[m]], termstartsub)
    # print(paste("d:", d))
    # print(paste("m:", m))
  }
}
```

# 3.0 Model Stats
```{r model_stats}
modelcoef <- replicate(n=ngates, expr=list())
modelpred <- replicate(n=ngates, expr=list())
modelstats_b <- replicate(n=ngates, expr=list())
modelstats_r2 <- replicate(n=ngates, expr=list())
modelstats_br2 <- replicate(n=ngates, expr=list())

r2 <- function(pred, obs){
  cor(pred, obs)^2
}

for(d in 1:ngates){
  for (m in 1:nformulas){
    # get the coefficients
    modelcoef[[d]][[m]] <- coef(modelfits[[d]][[m]])
    
    # use the fits to predict
    modelpred[[d]][[m]] <- predict(modelfits[[d]][[m]], data=flowdfl[[d]], type="response")
    
    # fit an lm to pred vs. obs to calculate b
    lmmod <- lm(modelpred[[d]][[m]]~flowdfl[[d]]$LOGFLOW)
    
    # calculate bR2 or bias-corrected R^2
    # For slope greater than one in the predicted vs. observed graph (meaning you are overpredicting), use the code below. It switches the y and x in the linear model and gives you the inverse slope, which is the R^2 (corrects over-prediction)
    if(lmmod$coefficients[2]>1){
      lmmod <- lm(flowdfl[[d]]$LOGFLOW~modelpred[[d]][[m]])
    }
    
    modelstats_b[[d]][[m]] <- lmmod$coefficients[2]
    modelstats_r2[[d]][[m]] <- r2(modelpred[[d]][[m]], flowdfl[[d]]$LOGFLOW)
    modelstats_br2[[d]][[m]] <- modelstats_b[[d]][[m]]*modelstats_r2[[d]][[m]]
  }
}
```

# 4.0 Model Plots
```{r model_plots}
# paste the equation for flow (use formula string) inside the plots, so we know what equation it was modeling without having to go back and forth
for(d in 1:ngates){
  for (m in 1:nformulas){
    png(paste0("outputs/obspreplots/ovp_d", d, "_m", m, ".png"), width=3.25, height=2.85, units="in", pointsize=8, res=1200)
    plot(flowdfl[[d]]$LOGFLOW, modelpred[[d]][[m]], ylab="Observed Log Flow", xlab="Predicted Log Flow")
    
    # add line for the perfect fit
    abline(0,1, col="grey80", lty=2, lwd=2)
    
    # add line for linear fit
    lmmod <- lm(modelpred[[d]][[m]]~flowdfl[[d]]$LOGFLOW)
    abline(lmmod, col="red")
    
    legend("bottomright", horiz=FALSE, inset=c(0.01, 0.01), cex=0.6, c("Y = X line", "regression line"), lty=c(2,1), lwd=c(2,1), col=c("grey80","red"), bg="grey96", xpd=TRUE)
    mtext(paste("Y =", round(lmmod$coefficients[2],3), "X +", round(lmmod$coefficients[1],0)), side=3, line=1, cex=0.8, adj=0.1)
  
    mtext(paste("Model bR2:", round(modelstats_br2[[d]][[m]],3)), side=3, line=0.3, cex=0.8, adj=0.1)
    dev.off()
  }
}
```

# 5.0 Uncertainty from flow table -- Monte Carlo Sim
In this section, we are searching for the distribution of errors (i.e., the shape of the PDF) necessary in the inputs (i.e., coefficients, G, and H) of the flow equation that produce a certain (i.e., +/-6% or +/-12%) error in the flow. 
Since flow is turbulent, let's assume a normal distribution of the errors. At a 95% confidence interval, with a normal distribution, we report the +/-2 standard deviation as the error. 
For simplicity, we will define the error distribution for coefficients of the equation to be all the same: normal distribution with the same coefficient of variation (standard deviation/mean).
For simplicity, we will consider all possible gate and upstream level heights as uniformly possible. Their distributions will be defined by the range of possible values. 
The variance in Q from the Monte-Carlo simulation is to equal the desired variance (objective function).
The decision variables are the parameters of the distributions that describe the PDF of the coefficients. 
```{r mcsim}
# model #5: Q = (aG^2 + bG + c)*H^(f)
# for data #1, picked model #5
# for data #2, picked model #5 update this with new data!!!!
# for data #3, picked model #5
# for data #4, picked model #5

# the number of Monte-Carlo loops
nsim <- 100

# for +/- 6% error of Q
# 2SD = 0.06 * Q
# SD = 0.03 * Q
# VAR^0.5 = 0.03 * Q
# VAR = 0.0009 * Q^2
set.seed(5152019)

coefofvar <- 0.459781
optvarflowp <- 9e-4
montecarlosim <- function(coefofvar, dataindex){
  d <- dataindex

  # we can add the ability to call different functions here, but for now just equation #5
  astdv <- coefofvar*modelcoef[[d]][[5]]["A"]
  anorm <- rnorm(nsim, modelcoef[[d]][[5]]["A"], astdv)
  bstdv <- coefofvar*modelcoef[[d]][[5]]["B"]
  bnorm <- rnorm(nsim, modelcoef[[d]][[5]]["B"], bstdv)
  cstdv <- coefofvar*modelcoef[[d]][[5]]["C"]
  cnorm <- rnorm(nsim, modelcoef[[d]][[5]]["C"], cstdv)
  ffstdv <- coefofvar*modelcoef[[d]][[5]]["FF"]
  ffnorm <- rnorm(nsim, modelcoef[[d]][[5]]["FF"], ffstdv)
  gunif <- runif(nsim, min(flowdfl[[d]]$G), max(flowdfl[[d]]$G))
  hunif <- runif(nsim, min(flowdfl[[d]]$H), max(flowdfl[[d]]$H))
  
  # to view them plot the histograms
  # hist(gunif)
  
  flowsim <- vector()
  for(i in 1:nsim){
    # we can add the ability to call different functions here, but for now just equation #5
    flowsim[i] <- (anorm[i]*gunif[i]^2 + bnorm[i]*gunif[i] + cnorm[i])*(hunif[i]^ffnorm[i])
  }
  stdvflow <- sd(flowsim)
  varflow <- sd(flowsim)^2
  optvarflow <- optvarflowp*mean(flowsim)^2 # mean(flowdfl[[d]]$FLOW) should be mean(flowsim), do with both and see if results of optimization vary or not
  resultstomin <- varflow - optvarflow
}

# why are the results so unstable, and so far from the optimum? and why are there warnings...
optresult <- replicate(n=ngates, expr=list())
for(d in 1:ngates){
  optresult[[d]] <- optim(par=c(1), fn=montecarlosim, dataindex=d, method="L-BFGS-B", lower=0, upper=50, control=list(trace=TRUE))
}

library(optimx)
optresult <- replicate(n=ngates, expr=list())
for(d in 1:ngates){
  optresult[[d]] <- optimx(par=c(1), fn=montecarlosim, dataindex=d, method="nlm", control=list(trace=TRUE, steptol=1e-2, maxit=1000))
}

# the function is too nonlinear for this optimization (?)
```

# 6.0 Uncertainty from operations -- Simulations
## 6.1 Uncertainty in Operational Flow
```{r opsim_flow}
# volume = t[Q] = t[(aG^2 + bG + c)*H^(f)]

opflowsim <- replicate(n=ngates, expr=list())
opvarflow <- replicate(n=ngates, expr=list())
opvolsim <- replicate(n=ngates, expr=list())
opvarvol <- replicate(n=ngates, expr=list())

for(d in 1:ngates){
  coefofvar <- optresult[[d]]$par
  astdv <- coefofvar*modelcoef[[d]][[5]]["A"]
  anorm <- rnorm(nsim, modelcoef[[d]][[5]]["A"], astdv)
  bstdv <- coefofvar*modelcoef[[d]][[5]]["B"]
  bnorm <- rnorm(nsim, modelcoef[[d]][[5]]["B"], bstdv)
  cstdv <- coefofvar*modelcoef[[d]][[5]]["C"]
  cnorm <- rnorm(nsim, modelcoef[[d]][[5]]["C"], cstdv)
  ffstdv <- coefofvar*modelcoef[[d]][[5]]["FF"]
  ffnorm <- rnorm(nsim, modelcoef[[d]][[5]]["FF"], ffstdv)
  # set the G, and H at a specific value, or itterate over operational G and H, either way if you are not changing the operational error in G and H then you should get the right results
  gnorm <- rnorm(nsim, 15,  0.01)
  hnorm <- rnorm(nsim, 0.79, 0.5)
  
  # uncertainty in operational flow
  opflowsim <- vector()
  for(i in 1:nsim){
    opflowsim[i] <- (anorm[i]*gunif[i]^2 + bnorm[i]*gunif[i] + cnorm[i])*(hunif[i]^ffnorm[i])
  }
  # opstdvflow <- sd(opflowsim) # this is superfluous but calculate it if you really want
  opvarflow[[d]] <- sd(opflowsim)^2
  
  # uncertainty in operational volume, added t in the equation
  tmean <- 12 # in hours
  tstdv <- 0.5 # conservative error estimates
  tnorm <- rnorm(nsim, tmean, tstdv)
  opvolsim <- vector()
  for(j in 1:nsim){
    opvolsim[j] <- (anorm[j]*gunif[j]^2 + bnorm[j]*gunif[j] + cnorm[j])*(hunif[j]^ffnorm[j])*tnorm[j]
  }
  # opstdvvol <- sd(opvolsim) # this is superfluous but calculate it if you really want
  opvarvol[[d]] <- sd(opvolsim)^2
  
  # consider having t=f(i or location)
  # canal has a capacity, they don't deliver to everyone at the same time (maybe won't matter)
  # dependency, he may pick a point of accuracy, deliver accurately to one and over deliver to someone else. or the middle of the canal as their point of accuracy. 
  # conceptual exercise
}
```



